<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Live Word Abbreviator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: system-ui, sans-serif;
      line-height: 1.55;
      padding: 1.25rem;
      max-width: 960px;
      margin: auto;
    }
    textarea {
      width: 100%;
      min-height: 160px;
      padding: 0.8rem 1rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 0.5rem;
      box-sizing: border-box;
      resize: vertical;
    }
    h1, h2 {
      font-weight: 600;
      margin: 1.2rem 0 0.75rem;
    }
    .controls {
      margin: 1.25rem 0;
    }
    label {
      margin-right: 1.5rem;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>
<body>
  <h1>Live Word Abbreviator</h1>

  <div class="controls">
    <label><input type="radio" name="mode" value="abbreviate" checked> Abbreviate</label>
    <label><input type="radio" name="mode" value="unabbreviate"> Unâ€‘abbreviate</label>
  </div>

  <textarea id="input" placeholder="Type here â€¦"></textarea>

  <h2>Output</h2>
  <textarea id="output" readonly placeholder="Converted text will appear here â€¦"></textarea>
  <p>More information at the <a href="https://github.com/thiagovscoelho/abbreviator">project page on GitHub</a>.</p>

  <script>
    (function () {
      /* -------------------------------------------------- */
      /* Data                                               */
      /* -------------------------------------------------- */
      const wordMap = {
        "the": "Ï„", "of": "âˆ©", "and": "&", "to": "â‡’", "in": "âŠ†", "is": "âˆˆ", "was": "Ï‰", "that": "é‚£",
        "for": "ğŸ’", "as": "âˆ·", "with": "ğ°", "by": "ğ›", "on": "ğŸ”›", "are": "ğ«", "from": "âŠ¸", "be": "ğ›",
        "or": "âˆ¨", "his": "â–´", "were": "Ï", "it": "â–¶", "an": "ğ§", "at": "@", "not": "Â¬", "which": "â¦‚",
        "have": "â‹‘", "he": "â–²", "had": "âŠ", "this": "è¿™", "has": "âŠƒ", "also": "âˆ§", "their": "â—‚", "but": "â§¹",
        "one": "ğŸ", "can": "ğŸ¥«", "its": "â–¸", "other": "â‰¢", "been": "ğŸš®", "more": ">", "they": "â—€", "used": "ìœ ",
        "first": "ğŸ¥‡", "all": "âˆ€", "two": "2", "than": "âŠ±", "up": "ğŸ†™", "your": "ğ’Œ¨", "look": "ğŸ‘€", "think": "ğŸ§ ",
        "want": "è¦", "us": "ğ‘ ", "you": "ğ®", "am": "ğ¦", "into": "â²", "would": "ğŸªµ", "only": "â‘ ", "time": "ğŸ•°ï¸", 
        "who": "ğŸ‘¤", "most": "âŠ¤", "may": "â—†", "such": "âˆ‹", "some": "âˆƒ", "many": "âˆ", "when": "ğ‘¡", "after": "â‰»", 
        "between": "â‰¬", "over": "â§¸", "these": "ğŸ¥œ", "her": "â–½", "about": "~", "there": "ğŸ“", "use": "ğŸ”§", 
        "no": "âˆ„", "them": "â—", "new": "ğŸ†•", "him": "â–³", "will": "â‡›", "out": "å‡º", "during": "âˆ¥", "made": "ğŸœ”", 
        "both": "âŠ“", "then": "â†’", "often": "â—•", "so": "â˜°", "any": "âœ²", "being": "ğŸ«˜", "where": "ğŸ—ºï¸", "number": "â„–",
        "could": "â—‡", "main": "ğŸ“Œ", "through": "â‡€", "system": "ğŸŒŒ", "people": "ğŸ‘¥", "known": "Îº", "each": "ğ",
        "while": "â²ï¸", "if": "ğ¶", "call": "ğŸ“", "same": "=", "later": "ğŸŒ‡", "three": "3", "because": "âˆµ",
        "well": "ğŸš°", "work": "ğ‘Š", "before": "â‰º", "different": "â‰ ", "she": "â–¼", "small": "Ïµ", "less": "<",
        "four": "4", "hers": "â–¿", "theirs": "â—ƒ"
      };

      const suffixMap = {
        "tion": "à¤¶", "ship": "ğŸš¢", "ing": "ğ‘›", "ed": "ğ‘‘", "er": "ğ‘Ÿ", "ers": "ğ‘Ÿs", "or": "ğ“‡", "ors": "ğ“‡s"
      };

      /* -------------------------------------------------- */
      /* Reverse maps                                       */
      /* -------------------------------------------------- */
      const reverseWordMap = Object.fromEntries(
        Object.entries(wordMap).map(([k, v]) => [v, k])
      );
      const reverseSuffixMap = Object.fromEntries(
        Object.entries(suffixMap).map(([k, v]) => [v, k])
      );

      /* -------------------------------------------------- */
      /* DOM                                                */
      /* -------------------------------------------------- */
      const inputEl = document.getElementById("input");
      const outputEl = document.getElementById("output");

      /* -------------------------------------------------- */
      /* Helpers                                            */
      /* -------------------------------------------------- */
      // Escape a string to be used in the body of new RegExp()
      const esc = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

      // Sort suffixes longestâ€‘toâ€‘shortest so longer matches win first
      const suffixEntries = Object.entries(suffixMap).sort((a, b) => b[0].length - a[0].length);
      const suffixEntriesRev = Object.entries(reverseSuffixMap).sort((a, b) => b[0].length - a[0].length);

      // A minimal boundary definition: letter/number/underscore (Unicodeâ€‘aware)
      const BASE_BOUNDARY = "\\p{L}\\p{N}_"; // note: used inside a characterâ€‘class later

      // Construct a regex that matches `token` only when it is not immediately
      // preceded/followed by BASE_BOUNDARY characters. Works in all modern
      // engines supporting lookahead (and *optional* lookbehind).
      function wholeTokenRegex(token) {
        // Leading boundary (captured so we can keep it in replacement)
        const before = `(^|[^${BASE_BOUNDARY}])`;
        // Trailing boundary checked with a lookâ€‘ahead â€” we don't want to consume it
        const after  = `(?=[^${BASE_BOUNDARY}]|$)`;
        return new RegExp(`${before}${esc(token)}${after}`, "gu");
      }

      /* -------------------------------------------------- */
      /* Forward (English âœ Abbreviated)                    */
      /* -------------------------------------------------- */
      function abbreviate(text) {
        // Wholeâ€‘word replacements (caseâ€‘insensitive)
        for (const [word, abbr] of Object.entries(wordMap)) {
          const re = new RegExp(`\\b${word}\\b`, "gi");
          text = text.replace(re, abbr);
        }
        // Suffix replacements
        for (const [suf, abbr] of suffixEntries) {
          const re = new RegExp(`${suf}\\b`, "gi");
          text = text.replace(re, abbr);
        }
        return text;
      }

      /* -------------------------------------------------- */
      /* Reverse (Abbreviated âœ English)                    */
      /* -------------------------------------------------- */
      function unabbreviate(text) {
        // Symbol tokens back to full words
        for (const [abbr, word] of Object.entries(reverseWordMap)) {
          text = text.replace(wholeTokenRegex(abbr), (_, lead) => `${lead}${word}`);
        }
        // Suffix symbols back to endings
        for (const [abbr, suf] of suffixEntriesRev) {
          const re = new RegExp(esc(abbr), "g");
          text = text.replace(re, suf);
        }
        return text;
      }

      /* -------------------------------------------------- */
      /* Glue                                               */
      /* -------------------------------------------------- */
      function convert() {
        const mode = document.querySelector('input[name="mode"]:checked').value;
        outputEl.value = (mode === "abbreviate")
          ? abbreviate(inputEl.value)
          : unabbreviate(inputEl.value);
      }

      inputEl.addEventListener("input", convert);
      document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener("change", convert));

      // Initial run (in case there is preâ€‘filled content)
      convert();
    })();
  </script>
</body>
</html>
